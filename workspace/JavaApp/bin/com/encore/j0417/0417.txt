class Parent{ }		// 추상클래스면 new Parent() 못함
class Child extents Parent{}

--------------------------------------------------
<메소드 정의>

 public void hello(Child c){
 
 }
 
 public void goodBye(Parent p){		//Parent p = new Child();
 
 }
--------------------------------------------------
 <메소드 호출>
 
 	hello(new Child());
 	Child cc = new Child();
 	hello();
 	
 	hello(new Parent()); (X) 부모는 자식에 대한 정보가 없다 / 자식객체에 부모객체가 들어갈 수 없다.
    ------------------------
	goodBye(new Parent());
	Parent pp = new Parent();
	goodBye(pp);
	
	goodBye(new Child));  (O)
	
====================================================================================

	void a(String greeting){

	}

	String b(int su){
		return "안녕하세요";
	}

	int c(){
		return 500;
	}
	
------------------------------------------
				a( b( c() ) );
	실행 순서 :   <---------
			c메소드 -> b메소드 -> a메소드 	
====================================================================================
<라인단위입력>
 클래스 BufferedReader -------> 메소드 readLine()
 API문서 정보 ===> BufferedReader(Reader in)
 		   ===> InputStreamReader(InputStream in)
 
 		A		 a	 = 	new A();
 	  Reader     r   =  new Reader(): (x) ---> 추상클래스 : 자식 ---> InputStreamReader
 InputStream 	 is	 =  System.in;
 Reader			 r   =  new InputStreamReader(is);
 BufferedReader  br	 = 	new	BufferedReader(r);
 
 BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
 public class BufferredReader extends Reader 

====================================================================================
<클래스 객체 생성>	----->	멤버(field, method)들에 대한 메모리 할당
 1. 동적 메모리 할당
 	- 사용안하는 객체에 대하여 가비지 컬렉터가 자동 소멸 관리
 	- 키워드 : new
 	- 사용법 : 참조변수를 통해 사용
 			 A a = new A();
 			   a.hello();
 			   
 2. 정적 메모리 할당
 	- 자주 사용되는 필드, 메소드에 대해 정의
 	- 객체들간의 통신에 사용 (공유 데이터를 표현)
 	- 키워드 : static
 	- 사용법 : 클래스명으로 참조 클래스 이름으로 접근
 			클래스명.필드명		클래스명.메소드명();	==> 클래스변수, 클래스메소드
 												==> static변수, static메소드
 							Math  . random();
 												
 	예) class B{
 			static public int su = 100;		// (O) -자료형 변수명 앞에는 순서 상관없음!
 			public static void goodBye(){} 	
 	   }
 	---------------------------------------------------
 		 <길동 개발자>			 	  <라임 개발자>
 		B.goodBye();			 B.goodBye();
 		Syso(B.su);	100출력 	    
 		 B.su++;
 		 						 Syso(B.su); 101출력
 		 						 
 		 						 
 	예) System.out   .println();
 			  ----   ----------
 			     필드	       메소드
 			     
 	public class System{
 		static PrintStream out;
 	}
====================================================================================
 <배열> Array
 - 자료형이 동일한 데이터들에 같은(한개의) 변수명을 정의한 자료들의 집합
 - 자료형이 동일한 데이터들       ==> 조건
      같은(한개의) 변수명을 정의  ==> 특성
      자료들의 집합                       ==> 정의
      
      int su1;	 -----> 한 개의 정수를 저장할 준비
      int []su2; -----> 여러개의 정수를 저장할 준비
      
 - 서로 데이터들을 구분하기 위해 번지를 사용
 - 시작 번지는 0번지, 1씩 증가하는 번지를 가짐
 
 - 배열의 크기가 정해지면 인덱스를 벗어나는 참조를 하면 안됨.
 	int []su3 = { 10, 20, 30 };
 	번지 인덱스  -->   0   1   2
	-----> 배열의 크기(요소 갯수) : 3 (인덱스 0~2)
	
	<5000 데이터 출력>
		System.out.println(5000);
	
		int su = 5000;
		System.out.println(su);
	
		int []suArr = { 5000 };
		System.out.println(suArr[0]);
		
		A []suArr = { new A(), a };
		System.out.println(suArr[0].hello());
		
 - 배열의 크기(배열의 요소 갯수)를 구하는 속성 : 배열명.length!	(배열은 객체다)
 
 - 배열선언시 []는 변수명 앞에 또는 뒤에 붙여도 상관이 없다.
 		int []su;
 		int su[];	
 		
 		int i;
 		int j;
 		int k;
 		===> int i, j, k;
 		
 		차이점)
 			int su1[], su2;	 -----> su1은 int배열, su2 int변수 
 			int [] su1, su2; -----> su1, su2 둘 다 int배열
 			
 참고) 
 	class A{
 		int i;					// 기본값 존재 o
 		
 		void hello(){
 			int j;				// 기본값 존재 x
 			Syso(i);			// 출력? O
 			
 			Syso(j);			// 출력? X	(초기화 하지 않았다는) 에러 발생
 			
 			j=0;
 			Syso(j);			// 출력 O
 				
 			int a, b, c = 0;	// c만 초기화 됨 
 			Syso(c);			// 출력 X
 			
 			Syso(a);			// 출력? X	(초기화 하지 않았다는) 에러 발생
 			Syso(b);			// 출력? X	(초기화 하지 않았다는) 에러 발생
 			
 			==> int a = 0, b = 0, c = 0;		// 각각 초기화
 		}
 	}
 	
 <배열 형식>
 1. 자료형[] 배열명 = { 데이터List(콤마로 구분) };
	------> 배열 선언과 동시에 데이터를 초기화. (이미 데이터가 확정 되었을때 주로 사용)
	
	Parent			 Parent, Child
 2. 자료형[] 배열명 = new 자료형[배열 크기];	// 배열 객체 생성식 : 암기!!!!!!!!
	------> 프로그램 실행 도중 데이터 값을 입력(변경)할 때 주로 사용.	
			==>  데이터가 정해지지 않고 앞으로 입력받을 데이터들이 저장될 방(공간)만 준비.
 	
 	
 	
 	
 	
 	
 	
 	
 	
 	
 	