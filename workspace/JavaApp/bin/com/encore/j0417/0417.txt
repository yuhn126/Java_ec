class Parent{ }		// 추상클래스면 new Parent() 못함
class Child extents Parent{}

--------------------------------------------------
<메소드 정의>

 public void hello(Child c){
 
 }
 
 public void goodBye(Parent p){		//Parent p = new Child();
 
 }
--------------------------------------------------
 <메소드 호출>
 
 	hello(new Child());
 	Child cc = new Child();
 	hello();
 	
 	hello(new Parent()); (X) 부모는 자식에 대한 정보가 없다 / 자식객체에 부모객체가 들어갈 수 없다.
    ------------------------
	goodBye(new Parent());
	Parent pp = new Parent();
	goodBye(pp);
	
	goodBye(new Child));  (O)
	
====================================================================================

	void a(String greeting){

	}

	String b(int su){
		return "안녕하세요";
	}

	int c(){
		return 500;
	}
	
------------------------------------------
				a( b( c() ) );
	실행 순서 :   <---------
			c메소드 -> b메소드 -> a메소드 	
====================================================================================
<라인단위입력>
 클래스 BufferedReader -------> 메소드 readLine()
 API문서 정보 ===> BufferedReader(Reader in)
 		   ===> InputStreamReader(InputStream in)
 
 		A		 a	 = 	new A();
 	  Reader     r   =  new Reader(): (x) ---> 추상클래스 : 자식 ---> InputStreamReader
 InputStream 	 is	 =  System.in;
 Reader			 r   =  new InputStreamReader(is);
 BufferedReader  br	 = 	new	BufferedReader(r);
 
 BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
 public class BufferredReader extends Reader 

====================================================================================
<클래스 객체 생성>	----->	멤버(field, method)들에 대한 메모리 할당
 1. 동적 메모리 할당
 	- 사용안하는 객체에 대하여 가비지 컬렉터가 자동 소멸 관리
 	- 키워드 : new
 	- 사용법 : 참조변수를 통해 사용
 			 A a = new A();
 			   a.hello();
 			   
 2. 정적 메모리 할당
 	- 자주 사용되는 필드, 메소드에 대해 정의
 	- 객체들간의 통신에 사용 (공유 데이터를 표현)
 	- 키워드 : static
 	- 사용법 : 클래스명으로 참조 클래스 이름으로 접근
 			클래스명.필드명		클래스명.메소드명();	==> 클래스변수, 클래스메소드
 												==> static변수, static메소드
 							Math  . random();
 												
 	예) class B{
 			static public int su = 100;		// (O) -자료형 변수명 앞에는 순서 상관없음!
 			public static void goodBye(){} 	
 	   }
 	---------------------------------------------------
 		 <길동 개발자>			 	  <라임 개발자>
 		B.goodBye();			 B.goodBye();
 		Syso(B.su);	100출력 	    
 		 B.su++;
 		 						 Syso(B.su); 101출력
 		 						 
 		 						 
 	예) System.out   .println();
 			  ----   ----------
 			     필드	       메소드
 			     
 	public class System{
 		static PrintStream out;
 	}
====================================================================================
 <배열> Array
 - 자료형이 동일한 데이터들에 같은(한개의) 변수명을 정의한 자료들의 집합
 - 자료형이 동일한 데이터들       ==> 조건
      같은(한개의) 변수명을 정의  ==> 특성
      자료들의 집합                       ==> 정의
      
      int su1;	 -----> 한 개의 정수를 저장할 준비
      int []su2; -----> 여러개의 정수를 저장할 준비
      
 - 서로 데이터들을 구분하기 위해 번지를 사용
 - 시작 번지는 0번지, 1씩 증가하는 번지를 가짐
 
 - 배열의 크기가 정해지면 인덱스를 벗어나는 참조를 하면 안됨.
 	int []su3 = { 10, 20, 30 };
 	번지 인덱스  -->   0   1   2
	-----> 배열의 크기(요소 갯수) : 3 (인덱스 0~2)
	
	<5000 데이터 출력>
		System.out.println(5000);
	
		int su = 5000;
		System.out.println(su);
	
		int []suArr = { 5000 };
		System.out.println(suArr[0]);
		
		A []suArr = { new A(), a };
		System.out.println(suArr[0].hello());
		
 - 배열의 크기(배열의 요소 갯수)를 구하는 속성 : 배열명.length!	(배열은 객체다)
 
 - 배열선언시 []는 변수명 앞에 또는 뒤에 붙여도 상관이 없다.
 		int []su;
 		int su[];	
 		
 		int i;
 		int j;
 		int k;
 		===> int i, j, k;
 		
 		차이점)
 			int su1[], su2;	 -----> su1은 int배열, su2 int변수 
 			int [] su1, su2; -----> su1, su2 둘 다 int배열
 			
 참고) 
 	class A{
 		int i;					// 기본값 존재 o
 		
 		void hello(){
 			int j;				// 기본값 존재 x
 			Syso(i);			// 출력? O
 			
 			Syso(j);			// 출력? X	(초기화 하지 않았다는) 에러 발생
 			
 			j=0;
 			Syso(j);			// 출력 O
 				
 			int a, b, c = 0;	// c만 초기화 됨 
 			Syso(c);			// 출력 X
 			
 			Syso(a);			// 출력? X	(초기화 하지 않았다는) 에러 발생
 			Syso(b);			// 출력? X	(초기화 하지 않았다는) 에러 발생
 			
 			==> int a = 0, b = 0, c = 0;		// 각각 초기화
 		}
 	}
 	
 <배열 형식>
 1. 자료형[] 배열명 = { 데이터List(콤마로 구분) };
	------> 배열 선언과 동시에 데이터를 초기화. (이미 데이터가 확정 되었을때 주로 사용)
	
	int [] su;	// 배열 서언
			su = { 1,2,3,4,5 };		// 배열 초기화(x)
			
	int [] su = { 1,2,3,4,5 };		// 선언과 초기화 (O) 
	
	A a = new A();
	A []su2 = { a, new A(), new A() };
	
	Parent			 Parent, Child
 2. 자료형[] 배열명 = new 자료형[배열 크기];	// 배열 객체 생성식 : 암기!!!!!!!!
	------> 프로그램 실행 도중 데이터 값을 입력(변경)할 때 주로 사용.	
			==>  데이터가 정해지지 않고 앞으로 입력받을 데이터들이 저장될 방(공간)만 준비.
	------> 배열 선언과 데이터 초기화하는 부분을 따로 작성하는 것이 가능
	------> 배열 크기[]는 반드시 자료형 뒤에 위치해야 함.
	------> 배열크기에 정수값이 반드시 입력되어야 함.
	
	int []su;					// 배열 선언
		  su = new int[5];		// 배열 초기화 (su배열 번수에 5개의 정수를 입력받겠음)
	===> int []su = new int[5];
	 * su = 참조변수
	
	===> 데이터 입력 :		su[0] = 11;
						su[1] = 22;
						su[2] = 33;
						su[3] = 44;
						su[4] = 55;
						
						su[5] = 66; ====> 인덱스를 벗어났으므로 에러
	* 배열 객체 생성(위의 2번)을 하게 되면 그 위치에 상관없이 각방에는 초기값이 부여됨.
	  (멤버변수처럼 각 자료형이 기본값이 입력됨)
						
 	
===================================================================================
<2차원 배열>
 - 실제 저장은 1차운 배열과 같으나 논리적으로 데이터를 행과 열의 형태로 저장한다고 생각 표현.
 - 행 사이즈는 반드시 기술해야 함, 열 사이즈는 생략하는 것이 가능
 
 	//배열 선언
 	int [][]su;
 	int su[][];
 	int []su[];
 	
 					   0행			 1행 
 				   -----------	------------
 	int [][]su = { { 1, 2, 3 }, { 4, 5, 6 } };
 					 -------      -------
 				  열 : 0  1  2      0  1  2
 				  
 				  System.out.println(su[0][2]);		// 0행 2열 데이터 ---> 3
 				  System.out.println(su[1][1]);		// 1행 1열 데이터 ---> 5
 				  
 		 su.length =====> 행의 갯수 =====> 2
 		 su[0].length ==> 0행의 열의 갯수 ==> 3
 		 su[1].length ==> 1행의 열의 갯수 ==> 3
 				  
 	===> for(int i = 0; i < su.length; i++){	// 기준(행) : 행의 인덱스 표현 0,1
 		 	for(int j = 0; i < su[i].length; j++){ // 각 행의 열 인덱스
 		 		System.out.println( su[i][j] );		// --> su배열 i행 j열
 			}
 		 }
 	
 	